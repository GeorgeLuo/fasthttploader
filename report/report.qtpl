{% import (
    "strings"
    "sync"
    "sort"
) %}

{% code
type Page struct {
    // Title displayed in title of generated report
    Title string

    // Step is measured in ms and used for TickInterval in charts
    Interval float64

    sync.Mutex
    Connections []uint64
	RequestSum []uint64
	RequestSuccess  []uint64
	Errors []uint64
	Timeouts []uint64
	Qps []uint64
	BytesWritten []uint64
	BytesRead []uint64
	RequestDuration map[float64][]float64
}

type seriesFunc func() string
%}

{% func (p *Page) title() %}{%s p.Title %}{% endfunc %}

{% func (p *Page) UpdateRequestDuration (d map[float64]float64) %}
	{% code
		for k, v := range d {
			if _, ok := p.RequestDuration[k]; !ok {
				p.RequestDuration[k] = make([]float64, 0)
			}

			p.RequestDuration[k] = append(p.RequestDuration[k], v)
		}
	%}
{% endfunc %}

{% func PrintPage(p *Page) %}
<html>
	<head>
		<title>{%= p.title() %}</title>
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
		<script type="text/javascript" src="https://code.highcharts.com/highcharts.js"></script>
		<script type="text/javascript" src="https://code.highcharts.com/modules/exporting.js"></script>
		<script type="text/javascript">{%s= jsUtils() %}</script>
	</head>
	 <body>
		{%= p.simpleChart("connections", p.connectionSeries) %}
		{%= p.simpleChart("qps", p.qpsSeries) %}
		{%= p.simpleChart("errors-vs-timeouts", p.errorSeries) %}
		{%= p.simpleChart("latency", p.durationSeries) %}
		{%= p.bytesChart("written-vs-read", p.bytesSeries) %}
	</body>
</html>
{% endfunc %}

{% func (p *Page) simpleChart(title string, fn seriesFunc) %}
	<script>
	$(function () {
    			$('#{%s= title %}').highcharts({
                				title: {
                					text: '{%s= strings.Title(title) %}',
                					x: -20 //center
                				},
                				xAxis: {
                					type: 'linear',
                				},
                				legend: {
                					layout: 'vertical',
                					align: 'right',
                					verticalAlign: 'middle',
                					borderWidth: 0
                				},
                				plotOptions: {
									series: {
										pointStart: 0,
										pointInterval: {%f.2= p.Interval %},
									}
								},
                				series: {%s= fn() %}
                			});
    		});
    </script>
   	<div id="{%s= title %}" style="min-width: 310px; height: 400px; margin: 0 auto"></div>
{% endfunc %}

{% func (p *Page) bytesChart(title string, fn seriesFunc) %}
	<script>
	$(function () {
    			$('#{%s= title %}').highcharts({
                				title: {
                					text: '{%s= strings.Title(title) %}',
                					x: -20 //center
                				},
                				xAxis: {
                					type: 'linear',
                				},
                				yAxis: {
									labels: {
										formatter: function() { return bytes(this.value, true); }
									},
									min: 0,
								},
								tooltip: {
									enabled: true,
									formatter: function() { return bytes(this.y, true);}
								},
                				legend: {
                					layout: 'vertical',
                					align: 'right',
                					verticalAlign: 'middle',
                					borderWidth: 0
                				},
                				plotOptions: {
									series: {
										pointStart: 0,
										pointInterval: {%f.2= p.Interval %},
									}
								},
                				series: {%s= fn() %}
                			});
    		});
    </script>
   	<div id="{%s= title %}" style="min-width: 310px; height: 400px; margin: 0 auto"></div>
{% endfunc %}

{% func (p *Page) connectionSeries()  %}
	[{
		name: 'Connections',
		data: [{%s= uint64SliceToString(p.Connections) %}]
	}]
{% endfunc %}

{% func (p *Page) qpsSeries() %}
	[{
		name: 'Qps',
		data: [{%s= uint64SliceToString(p.Qps) %}]
	},
	{
		name: 'Req-per-sample',
		data: [{%s= float64SliceToString(rate(p.RequestSum, p.Interval)) %}]
	}]
{% endfunc %}

{% func (p *Page) errorSeries() %}
	[{
		name: 'Errors',
		data: [{%s= float64SliceToString(rate(p.Errors, p.Interval)) %}]
	},{
		name: 'Timeouts',
		data: [{%s= float64SliceToString(rate(p.Timeouts, p.Interval)) %}]
	}]
{% endfunc %}

{% stripspace %}
{% func (p *Page) durationSeries() %}
	[
    {% code
		var keys []float64
        for k := range p.RequestDuration {
            keys = append(keys, k)
        }
        sort.Float64s(keys)
	%}
	{% for i, k := range keys %}
		{
			name: '{%f= k %}',
			data: [{%s= float64SliceToString(p.RequestDuration[k]) %}],
			tooltip: {valueSuffix: ' s'}
		}
		{% if i + 1 < len(keys) %},{% endif %}
	{% endfor %}
	]
{% endfunc %}
{% endstripspace %}

{% stripspace %}
{% func (p *Page) bytesSeries() %}
	[{
    		name: 'BytesWritten',
    		data: [{%s= float64SliceToString(rate(p.BytesWritten, p.Interval)) %}]
    	},{
    		name: 'BytesRead',
    		data: [{%s= float64SliceToString(rate(p.BytesRead, p.Interval)) %}]
    	}]
{% endfunc %}
{% endstripspace %}

{% func jsUtils() %}
	function bytes(bytes, label) {
        if (bytes == 0) return '';
        var s = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
        var e = Math.floor(Math.log(bytes)/Math.log(1024));
        var value = ((bytes/Math.pow(1024, Math.floor(e))).toFixed(2));
        e = (e<0) ? (-e) : e;
        if (label) value += ' ' + s[e];
        return value;
    }
{% endfunc %}
